<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>puma原理解析 | 把酒东风</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="版本 ruby 2.6.6 rails 6.0.2.2 puma-4.3.3参考 https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24378 https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24426  https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24529 https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24599 https:&#x2F;&#x2F;justjj">
<meta property="og:type" content="article">
<meta property="og:title" content="puma原理解析">
<meta property="og:url" content="http://yoursite.com/2020/05/12/puma%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="把酒东风">
<meta property="og:description" content="版本 ruby 2.6.6 rails 6.0.2.2 puma-4.3.3参考 https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24378 https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24426  https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24529 https:&#x2F;&#x2F;ruby-china.org&#x2F;topics&#x2F;24599 https:&#x2F;&#x2F;justjj">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://139.196.124.252//uploads/image/Article/48/2017-11-10-puma-concurrency-model.png">
<meta property="og:image" content="http://139.196.124.252/uploads/image/Article/47/WechatIMG57.png">
<meta property="og:image" content="http://139.196.124.252//uploads/image/Article/50/puma_handle.jpg">
<meta property="article:published_time" content="2020-05-12T08:05:29.000Z">
<meta property="article:modified_time" content="2020-05-12T08:05:50.573Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="puma rails">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://139.196.124.252//uploads/image/Article/48/2017-11-10-puma-concurrency-model.png">
  
    <link rel="alternate" href="/atom.xml" title="把酒东风" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">把酒东风</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-puma原理解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/puma%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2020-05-12T08:05:29.000Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      puma原理解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ul>
<li>ruby 2.6.6</li>
<li>rails 6.0.2.2</li>
<li>puma-4.3.3<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></li>
<li><a href="https://ruby-china.org/topics/24378" target="_blank" rel="noopener">https://ruby-china.org/topics/24378</a></li>
<li><a href="https://ruby-china.org/topics/24426" target="_blank" rel="noopener">https://ruby-china.org/topics/24426</a> </li>
<li><a href="https://ruby-china.org/topics/24529" target="_blank" rel="noopener">https://ruby-china.org/topics/24529</a></li>
<li><a href="https://ruby-china.org/topics/24599" target="_blank" rel="noopener">https://ruby-china.org/topics/24599</a></li>
<li><a href="https://justjjy.com/PUMA-shi-xian-jian-yao-fen-xi" target="_blank" rel="noopener">https://justjjy.com/PUMA-shi-xian-jian-yao-fen-xi</a></li>
<li><a href="https://draveness.me/rack-puma" target="_blank" rel="noopener">https://draveness.me/rack-puma</a></li>
</ul>
<h3 id="puma架构图"><a href="#puma架构图" class="headerlink" title="puma架构图"></a>puma架构图</h3><p><img src="http://139.196.124.252//uploads/image/Article/48/2017-11-10-puma-concurrency-model.png" alt="puma架构图"></p>
<ul>
<li>1个master进程<ul>
<li>负责管理work进程.</li>
<li>创建worker进程，然后开启循环，不断的监听work 进程的状态，然后根据收到的信号产生响应的动作，比如重启worker进程。</li>
</ul>
</li>
<li>n个worker进程<ul>
<li>负责处理请求。</li>
<li>每个进程都有一个puma::server 用来处理请求。puma::server 初始化线程池，然后不断的监听socket的，把请求源源不断的加入到线程池，而线程池的线程也是一个while true的循环，时刻拉去请求，进行处理。<h3 id="启动展示"><a href="#启动展示" class="headerlink" title="启动展示"></a>启动展示</h3><img src="http://139.196.124.252/uploads/image/Article/47/WechatIMG57.png" alt="启动过程状态"><br>可以看到当前是两个进程，每个进程的线程数是2~5.</li>
</ul>
</li>
</ul>
<p>可以通过设置 <strong>config/puma.rb</strong> 文件实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">max_threads_count &#x3D; ENV.fetch(&#39;RAILS_MAX_THREADS&#39;) &#123; 5 &#125;</span><br><span class="line">min_threads_count &#x3D; ENV.fetch(&#39;RAILS_MIN_THREADS&#39;) &#123; 2 &#125;</span><br><span class="line">....</span><br><span class="line">workers ENV.fetch(&quot;WEB_CONCURRENCY&quot;) &#123; 2 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何启动server"><a href="#如何启动server" class="headerlink" title="如何启动server"></a>如何启动server</h3><ul>
<li>本文不做重点详细可以阅读 <a href="https://ruby-china.github.io/rails-guides/initialization.html" target="_blank" rel="noopener">rails初始化</a></li>
<li>运行 rails s 最终是跑到rack 里执行了 <strong>Rack::Server.start</strong></li>
<li>粗略看 Rack::Server<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># rack-2.2.2</span><br><span class="line"># lib&#x2F;rack&#x2F;server.rb</span><br><span class="line"></span><br><span class="line">def self.start(options &#x3D; nil)</span><br><span class="line">  new(options).start</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def start(&amp;block)</span><br><span class="line">  ..... #省略了好多代码</span><br><span class="line">  server.run(wrapped_app, **options, &amp;block)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
关键点就是<strong>server.run</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># rack-2.2.2</span><br><span class="line"># lib&#x2F;rack&#x2F;server.rb</span><br><span class="line">def server</span><br><span class="line">  # 默认options[:server]是nil。</span><br><span class="line">  @_server ||&#x3D; Rack::Handler.get(options[:server])</span><br><span class="line"></span><br><span class="line">  unless @_server</span><br><span class="line">    @_server &#x3D; Rack::Handler.default</span><br><span class="line"></span><br><span class="line">    # We already speak FastCGI</span><br><span class="line">    @ignore_options &#x3D; [:File, :Port] if @_server.to_s &#x3D;&#x3D; &#39;Rack::Handler::FastCGI&#39;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  @_server</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
因此获取server的关键点就是 <strong>Rack::Handler.default</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rack-2.2.2</span><br><span class="line"># lib&#x2F;rack&#x2F;handler.rb</span><br><span class="line"></span><br><span class="line">Rack::Handler.default</span><br><span class="line">&#x3D;&gt;Rack::Handler::Puma</span><br></pre></td></tr></table></figure>
<p>接下来是 <strong>run</strong> 方法。可以继续往下看。</p>
<h3 id="先看出来流程图"><a href="#先看出来流程图" class="headerlink" title="先看出来流程图"></a>先看出来流程图</h3><p><img src="http://139.196.124.252//uploads/image/Article/50/puma_handle.jpg" alt="puma请求处理流程"></p>
<h3 id="初入puma"><a href="#初入puma" class="headerlink" title="初入puma"></a>初入puma</h3><ul>
<li><p>简单阅读下 <strong>Rack::Handler::Puma</strong> 源码,当前类主要是读取配置验证配置。可以结合 <strong>::Puma::Configuration</strong>（主要用于处理配置文件） 阅读。</p>
<ul>
<li>::Puma::Configuration 位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;configuration.rb</span><br></pre></td></tr></table></figure></li>
<li>来看最关键的 <strong>run</strong> 方法，这里和上边连起来了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;rack&#x2F;handler&#x2F;puma.rb</span><br><span class="line"></span><br><span class="line">  def self.run(app, options &#x3D; &#123;&#125;)</span><br><span class="line">    conf   &#x3D; self.config(app, options)</span><br><span class="line"></span><br><span class="line">    events &#x3D; options.delete(:Silent) ? ::Puma::Events.strings : ::Puma::Events.stdio</span><br><span class="line"></span><br><span class="line">    launcher &#x3D; ::Puma::Launcher.new(conf, :events &#x3D;&gt; events)</span><br><span class="line"></span><br><span class="line">    yield launcher if block_given?</span><br><span class="line">    begin</span><br><span class="line">      launcher.run</span><br><span class="line">    rescue Interrupt</span><br><span class="line">      puts &quot;* Gracefully stopping, waiting for requests to finish&quot;</span><br><span class="line">      launcher.stop</span><br><span class="line">      puts &quot;* Goodbye!&quot;</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure></li>
<li>此时就可以发现关键的过程是由 <strong>::Puma::Launcher</strong>来实现的，当前的 <strong>run</strong>方法主要是生成了 <strong>::Puma::Launcher</strong> 实例同时调用其 <strong>run</strong> 方法。</li>
</ul>
</li>
<li><p>阅读 <strong>::Puma::Launcher</strong> 的代码</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;launcher.rb</span><br><span class="line"></span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line">#   conf &#x3D; Puma::Configuration.new do |user_config|</span><br><span class="line">#     user_config.threads 1, 10</span><br><span class="line">#     user_config.app do |env|</span><br><span class="line">#       [200, &#123;&#125;, [&quot;hello world&quot;]]</span><br><span class="line">#     end</span><br><span class="line">#   end</span><br><span class="line">#   Puma::Launcher.new(conf, events:Puma::Events.stdio).run</span><br><span class="line">def initialize(conf, launcher_args&#x3D;&#123;&#125;)</span><br><span class="line">  @runner        &#x3D; nil</span><br><span class="line">  @events        &#x3D; launcher_args[:events] || Events::DEFAULT</span><br><span class="line">  @argv          &#x3D; launcher_args[:argv] || []</span><br><span class="line">  @original_argv &#x3D; @argv.dup</span><br><span class="line">  @config        &#x3D; conf</span><br><span class="line"></span><br><span class="line">  @binder        &#x3D; Binder.new(@events)</span><br><span class="line">  @binder.import_from_env</span><br><span class="line"></span><br><span class="line">  @environment &#x3D; conf.environment</span><br><span class="line">  。。。。# 省略了很多代码</span><br><span class="line"></span><br><span class="line">  if clustered?</span><br><span class="line">    @options[:logger] &#x3D; @events</span><br><span class="line"></span><br><span class="line">    @runner &#x3D; Cluster.new(self, @events)</span><br><span class="line">  else</span><br><span class="line">    @runner &#x3D; Single.new(self, @events)</span><br><span class="line">  end</span><br><span class="line">  Puma.stats_object &#x3D; @runner</span><br><span class="line"></span><br><span class="line">  @status &#x3D; :run</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def clustered?</span><br><span class="line">  (@options[:workers] || 0) &gt; 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的绝大部分代码还都是在做配置方面的东西，而整个初始化方法中需要注意的地方也只有不同 @runner 的初始化了。</li>
<li>在 #initialize 方法中，@runner 的初始化是根据当前配置中的 worker 数决定的，如果当前的 worker &gt; 0，那么就会选择 Cluster 作为 @runner，否则就会选择 Single.</li>
<li>在初始化结束之后会执行 Launcher#run 方法启动当前的 Puma 进程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;launcher.rb</span><br><span class="line">def run</span><br><span class="line">  。。。 &#x2F;&#x2F; 省略了很多代码</span><br><span class="line">  setup_signals</span><br><span class="line">  set_process_title</span><br><span class="line">  @runner.run</span><br><span class="line">  # 这里等待runner运行结束，一般是收到了KILL类信号</span><br><span class="line">  case @status</span><br><span class="line">  when :halt</span><br><span class="line">    log &quot;* Stopping immediately!&quot;</span><br><span class="line">  when :run, :stop</span><br><span class="line">    graceful_stop</span><br><span class="line">  when :restart</span><br><span class="line">    log &quot;* Restarting...&quot;</span><br><span class="line">    ENV.replace(previous_env)</span><br><span class="line">    @runner.before_restart</span><br><span class="line">    restart!</span><br><span class="line">  when :exit</span><br><span class="line">    # nothing</span><br><span class="line">  end</span><br><span class="line">  @binder.close_unix_paths</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>设置操作系统信号的处理函数、设置 puma 进程标题, 设置 puma 主进程的状态为:run，并执行 runner 的 run 方法。run 方法进行几层的封装，最终会执行到 Server 类的 run 方法, 这里有个关键的循环。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;server.rb</span><br><span class="line">def handle_servers</span><br><span class="line">    ..... # 省略好多代码</span><br><span class="line">    while @status &#x3D;&#x3D; :run</span><br><span class="line">      begin</span><br><span class="line">        ios &#x3D; IO.select sockets</span><br><span class="line">        ios.first.each do |sock|</span><br><span class="line">        ..... # 省略好多代码</span><br><span class="line">        end</span><br><span class="line">      rescue Object &#x3D;&gt; e</span><br><span class="line">        @events.unknown_error self, e, &quot;Listen loop&quot;</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">    ..... # 省略好多代码</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>此时 puma 服务器就可以接收 web 客户端的请求了，同时等待操作系统的退出信号。当收到操作系统的退出信号后，代码执行到 case @status处，这里判断信号类型来决定是停止还是重启 puma。</li>
<li>额外话题  设置信号,例如通过kill -USR2 ProcessID可以重启应用就是这里实现的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;launcher.rb</span><br><span class="line">def setup_signals</span><br><span class="line">  begin</span><br><span class="line">    Signal.trap &quot;SIGUSR2&quot; do</span><br><span class="line">      restart</span><br><span class="line">    end</span><br><span class="line">  rescue Exception</span><br><span class="line">    log &quot;*** SIGUSR2 not implemented, signal based restart unavailable!&quot;</span><br><span class="line">  end</span><br><span class="line">  。。。&#x2F;&#x2F; 省略了很多代码</span><br><span class="line">  begin</span><br><span class="line">    Signal.trap &quot;SIGTERM&quot; do</span><br><span class="line">      graceful_stop</span><br><span class="line"></span><br><span class="line">      raise(SignalException, &quot;SIGTERM&quot;) if @options[:raise_exception_on_sigterm]</span><br><span class="line">    end</span><br><span class="line">  rescue Exception</span><br><span class="line">    log &quot;*** SIGTERM not implemented, signal based gracefully stopping unavailable!&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  begin</span><br><span class="line">    Signal.trap &quot;SIGINFO&quot; do</span><br><span class="line">      log_thread_status</span><br><span class="line">    end</span><br><span class="line">  rescue Exception</span><br><span class="line">    # Not going to log this one, as SIGINFO is *BSD only and would be pretty annoying</span><br><span class="line">    # to see this constantly on Linux.</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3></li>
</ul>
</li>
<li><p>根据配置文件中不同的配置项，Puma 在启动时有两种不同的选择，一种是当前的 worker 数为 0，这时会通过 Single 启动单机模式的 Puma 进程，另一种情况是 worker 数大于 0，它使用 Cluster 的 runner 启动一组 Puma 进程。</p>
</li>
<li><p>无论是Single 还是Cluster 都是集成于 <strong>Puma::Runner</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;single.rb</span><br><span class="line">module Puma</span><br><span class="line">    class Single &lt; Runner</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;cluster.rb</span><br><span class="line">module Puma</span><br><span class="line">    class Cluster &lt; Runner</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h4></li>
<li><p>Puma 单机模式的启动通过 Single 类来处理.</p>
</li>
<li><p>来看下代码</p>
<ul>
<li>判断是否要以 daemon 的方法运行 puma，</li>
<li>后加载配置文件并确定监听哪些网络接口</li>
<li>把 puma 的进程 pid以及状态信息写入状态文件中</li>
<li>启动运行时控制服务器的网络接口，然后通知启动监听者 puma 启动了，最后是运行 Server 类的 run 方法,这个方法返回值是Thread实例 <strong>join</strong> 是主线程挂起，等待当前线程执行结束再执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;single.rb</span><br><span class="line">    def run</span><br><span class="line">        if daemon?</span><br><span class="line">          log &quot;* Daemonizing...&quot;</span><br><span class="line">          Process.daemon(true)</span><br><span class="line">          redirect_io</span><br><span class="line">        end</span><br><span class="line">        load_and_bind</span><br><span class="line">      @launcher.write_state</span><br><span class="line">      @server &#x3D; server &#x3D; start_server</span><br><span class="line">      unless daemon?</span><br><span class="line">        log &quot;Use Ctrl-C to stop&quot;</span><br><span class="line">        redirect_io</span><br><span class="line">      end</span><br><span class="line">      begin</span><br><span class="line">        server.run.join</span><br><span class="line">      rescue Interrupt</span><br><span class="line">        # Swallow it</span><br><span class="line">      end</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
在后台运行puma的master进程，然后启动puma的服务器，也就是<br>server 也就是 <strong>Puma::Server</strong>，看代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;runner.rb</span><br><span class="line">def start_server</span><br><span class="line">  min_t &#x3D; @options[:min_threads]</span><br><span class="line">  max_t &#x3D; @options[:max_threads]</span><br><span class="line"></span><br><span class="line">  server &#x3D; Puma::Server.new app, @launcher.events, @options</span><br><span class="line">  server.min_threads &#x3D; min_t</span><br><span class="line">  server.max_threads &#x3D; max_t</span><br><span class="line">  server.inherit_binder @launcher.binder</span><br><span class="line"></span><br><span class="line">  server</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>研究下 <strong>Puma::Server</strong> 的代码</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;server.rb</span><br><span class="line"># The HTTP Server itself. Serves out a single Rack app.</span><br><span class="line">#</span><br><span class="line"># This class is used by the &#96;Puma::Single&#96; and &#96;Puma::Cluster&#96; classes</span><br><span class="line"># to generate one or more &#96;Puma::Server&#96; instances capable of handling requests.</span><br><span class="line"># Each Puma process will contain one &#96;Puma::Server&#96; instance.</span><br><span class="line">#</span><br><span class="line"># The &#96;Puma::Server&#96; instance pulls requests from the socket, adds them to a</span><br><span class="line"># &#96;Puma::Reactor&#96; where they get eventually passed to a &#96;Puma::ThreadPool&#96;.</span><br><span class="line">#</span><br><span class="line"># Each &#96;Puma::Server&#96; will have one reactor and one thread pool.</span><br><span class="line">module Puma</span><br><span class="line">    class Server</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>  先看下注释，可以知道这个类是真正用于处理请求的，每个work进程都有一个 <strong>Puma::Server</strong> 实例。</p>
<ul>
<li>接着看下 <strong>run</strong>方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"># puma-4.3.3</span><br><span class="line"># lib&#x2F;puma&#x2F;server.rb</span><br><span class="line">def run(background&#x3D;true)</span><br><span class="line">  @status &#x3D; :run</span><br><span class="line">  queue_requests &#x3D; @queue_requests</span><br><span class="line"></span><br><span class="line">  @thread_pool &#x3D; ThreadPool.new(@min_threads,</span><br><span class="line">                                @max_threads,</span><br><span class="line">                                IOBuffer) do |client, buffer|</span><br><span class="line"></span><br><span class="line">    # Advertise this server into the thread</span><br><span class="line">    Thread.current[ThreadLocalKey] &#x3D; self</span><br><span class="line"></span><br><span class="line">    process_now &#x3D; false</span><br><span class="line"></span><br><span class="line">    begin</span><br><span class="line">      if queue_requests</span><br><span class="line">        process_now &#x3D; client.eagerly_finish</span><br><span class="line">      else</span><br><span class="line">        client.finish</span><br><span class="line">        process_now &#x3D; true</span><br><span class="line">      end</span><br><span class="line">    rescue MiniSSL::SSLError &#x3D;&gt; e</span><br><span class="line">      ssl_socket &#x3D; client.io</span><br><span class="line">      addr &#x3D; ssl_socket.peeraddr.last</span><br><span class="line">      cert &#x3D; ssl_socket.peercert</span><br><span class="line"></span><br><span class="line">      client.close</span><br><span class="line"></span><br><span class="line">      @events.ssl_error self, addr, cert, e</span><br><span class="line">    rescue HttpParserError &#x3D;&gt; e</span><br><span class="line">      client.write_error(400)</span><br><span class="line">      client.close</span><br><span class="line"></span><br><span class="line">      @events.parse_error self, client.env, e</span><br><span class="line">    rescue ConnectionError, EOFError</span><br><span class="line">      client.close</span><br><span class="line">    else</span><br><span class="line">      if process_now</span><br><span class="line">        process_client client, buffer</span><br><span class="line">      else</span><br><span class="line">        client.set_timeout @first_data_timeout</span><br><span class="line">        @reactor.add client</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  @thread_pool.clean_thread_locals &#x3D; @options[:clean_thread_locals]</span><br><span class="line"></span><br><span class="line">  if queue_requests</span><br><span class="line">    @reactor &#x3D; Reactor.new self, @thread_pool</span><br><span class="line">    @reactor.run_in_thread</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  if @reaping_time</span><br><span class="line">    @thread_pool.auto_reap!(@reaping_time)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  if @auto_trim_time</span><br><span class="line">    @thread_pool.auto_trim!(@auto_trim_time)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  @events.fire :state, :running</span><br><span class="line"></span><br><span class="line">  if background</span><br><span class="line">    @thread &#x3D; Thread.new do</span><br><span class="line">      Puma.set_thread_name &quot;server&quot;</span><br><span class="line">      handle_servers</span><br><span class="line">    end</span><br><span class="line">    return @thread</span><br><span class="line">  else</span><br><span class="line">    handle_servers</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>服务在启动时会创建一个线程池 ThreadPool 并传入一个用于处理请求的 block</li>
<li>如果 background 设置为 true，那么会在一个新线程中运行实际的 handle_servers 代码，否则会同步执行。</li>
<li>Puma 服务器通过@status变量控制其运行。当@status为:run 的时候，服务器处于运行状态，当外部操作导致@status变化时，puma 进入关闭／重启流程。</li>
<li>具体稍后再说</li>
</ul>
</li>
</ul>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><ul>
<li>刚开始我们启动了puma，就会启动一个master 进程和2个worker 进程。puma集群模式就是通过 <strong>Puma::Cluster</strong>类来启动的。</li>
<li>来看下 <strong>Puma::Cluster</strong>的run方法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def run</span><br><span class="line">  @status &#x3D; :run</span><br><span class="line">  setup_signals</span><br><span class="line">  spawn_workers</span><br><span class="line">  begin</span><br><span class="line">    force_check &#x3D; false</span><br><span class="line">    </span><br><span class="line">    while @status &#x3D;&#x3D; :run</span><br><span class="line">      begin</span><br><span class="line">        check_workers force_check</span><br><span class="line">        </span><br><span class="line">        res &#x3D; IO.select([read], nil, nil, Const::WORKER_CHECK_INTERVAL)</span><br><span class="line"></span><br><span class="line">        if res</span><br><span class="line">          req &#x3D; read.read_nonblock(1)</span><br><span class="line">    </span><br><span class="line">          next if !req || req &#x3D;&#x3D; &quot;!&quot;</span><br><span class="line">    </span><br><span class="line">          result &#x3D; read.gets</span><br><span class="line">          pid &#x3D; result.to_i</span><br><span class="line">    </span><br><span class="line">          if w &#x3D; @workers.find &#123; |x| x.pid &#x3D;&#x3D; pid &#125;</span><br><span class="line">            case req</span><br><span class="line">            when &quot;b&quot;</span><br><span class="line">              w.boot!</span><br><span class="line">              log &quot;- Worker #&#123;w.index&#125; (pid: #&#123;pid&#125;) booted, phase: #&#123;w.phase&#125;&quot;</span><br><span class="line">              force_check &#x3D; true</span><br><span class="line">            when &quot;e&quot;</span><br><span class="line">              # external term, see worker method, Signal.trap &quot;SIGTERM&quot;</span><br><span class="line">              w.instance_variable_set :@term, true</span><br><span class="line">            when &quot;t&quot;</span><br><span class="line">              w.term unless w.term?</span><br><span class="line">              force_check &#x3D; true</span><br><span class="line">            when &quot;p&quot;</span><br><span class="line">              w.ping!(result.sub(&#x2F;^\d+&#x2F;,&#39;&#39;).chomp)</span><br><span class="line">            end</span><br><span class="line">          else</span><br><span class="line">            log &quot;! Out-of-sync worker list, no #&#123;pid&#125; worker&quot;</span><br><span class="line">          end</span><br><span class="line">        end</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>
<ul>
<li>先来看下 <strong>spawn_workers</strong> 方法,主要就是fork出你配置的work进程。当进程fork出来以后，master进程就开始检查，并且监听来自worker的消息，例如例如当前的状态以及心跳检查等等。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def spawn_workers</span><br><span class="line">  diff &#x3D; @options[:workers] - @workers.size</span><br><span class="line">  return if diff &lt; 1</span><br><span class="line"></span><br><span class="line">  master &#x3D; Process.pid</span><br><span class="line"></span><br><span class="line">  diff.times do</span><br><span class="line">    idx &#x3D; next_worker_index</span><br><span class="line"></span><br><span class="line">    pid &#x3D; fork &#123; worker(idx, master) &#125;</span><br><span class="line">    </span><br><span class="line">    @workers &lt;&lt; Worker.new(idx, pid, @phase, @options)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>在fork 出来的进程中执行worker方法。#worker 方法与单机模式中一样都创建了新的 Server 实例，调用 #run 和 #join 方法启动服务：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def worker(index, master)</span><br><span class="line">  server &#x3D; start_server</span><br><span class="line"></span><br><span class="line">  begin</span><br><span class="line">    @worker_write &lt;&lt; &quot;b#&#123;Process.pid&#125;\n&quot;</span><br><span class="line">  rescue SystemCallError, IOError</span><br><span class="line">    Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue</span><br><span class="line">    STDERR.puts &quot;Master seems to have exited, exiting.&quot;</span><br><span class="line">    return</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  server.run.join</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3>在 Puma 中所有的请求都是通过 Server 和 ThreadPool 协作来响应的，我们在 #handler_servers 方法中通过 IO.select 监听一组套接字上的读写事件，从socket 中读取请求，创建新的 Client 对象最后加入到线程池中交给线程池来处理接下来的请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def handle_servers</span><br><span class="line">  begin</span><br><span class="line">    check &#x3D; @check</span><br><span class="line">    sockets &#x3D; [check] + @binder.ios</span><br><span class="line">    pool &#x3D; @thread_pool</span><br><span class="line">    queue_requests &#x3D; @queue_requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while @status &#x3D;&#x3D; :run</span><br><span class="line">      begin</span><br><span class="line">        ios &#x3D; IO.select sockets</span><br><span class="line">        ios.first.each do |sock|</span><br><span class="line">            begin</span><br><span class="line">              if io &#x3D; sock.accept_nonblock</span><br><span class="line">                client &#x3D; Client.new io, @binder.env(sock)</span><br><span class="line"></span><br><span class="line">                pool &lt;&lt; client</span><br><span class="line">                busy_threads &#x3D; pool.wait_until_not_full</span><br><span class="line">              end</span><br><span class="line">            end</span><br><span class="line">          end</span><br><span class="line">        end</span><br><span class="line">      rescue Object &#x3D;&gt; e</span><br><span class="line">        @events.unknown_error self, e, &quot;Listen loop&quot;</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module Puma</span><br><span class="line">  # An instance of this class represents a unique request from a client.</span><br><span class="line">  # For example, this could be a web request from a browser or from CURL.</span><br><span class="line">  #</span><br><span class="line">  class Client</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>在初始化方法 #initialize 中，线程池在初始化时就会创建最低数量的线程保证当前的 worker 进程中有足够的工作线程能够处理客户端的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module Puma</span><br><span class="line">  # Internal Docs for A simple thread pool management object.</span><br><span class="line">  #</span><br><span class="line">  # Each Puma &quot;worker&quot; has a thread pool to process requests.</span><br><span class="line">  # Once the request is ready, it is passed into</span><br><span class="line">  # a thread pool via the &#96;Puma::ThreadPool#&lt;&lt;&#96; operator where it is stored in a &#96;@todo&#96; array.</span><br><span class="line">  #</span><br><span class="line">  # Each thread in the pool has an internal loop where it pulls a request from the &#96;@todo&#96; array</span><br><span class="line">  # and proceses it.</span><br><span class="line">  class ThreadPool</span><br><span class="line">    def initialize(min, max, *extra, &amp;block)</span><br><span class="line"></span><br><span class="line">      @min &#x3D; Integer(min)</span><br><span class="line">      @max &#x3D; Integer(max)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      @mutex.synchronize do</span><br><span class="line">        @min.times &#123; spawn_thread &#125;</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>ThreadPool 覆写了 #&lt;&lt; 方法，在这个方法中它将 Client 对象加入到 @todo 数组中，通过对比几个参数选择是否创建一个新的线程来处理当前队列中的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Add +work+ to the todo list for a Thread to pickup and process.</span><br><span class="line">def &lt;&lt;(work)</span><br><span class="line">  @mutex.synchronize do</span><br><span class="line">    if @shutdown</span><br><span class="line">      raise &quot;Unable to add work while shutting down&quot;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    @todo &lt;&lt; work</span><br><span class="line"></span><br><span class="line">    if @waiting &lt; @todo.size and @spawned &lt; @max</span><br><span class="line">      spawn_thread</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    @not_empty.signal</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>然后我们看下 <strong>spawn_thread</strong> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def spawn_thread</span><br><span class="line">  @spawned +&#x3D; 1</span><br><span class="line"></span><br><span class="line">  th &#x3D; Thread.new(@spawned) do |spawned|</span><br><span class="line">    Puma.set_thread_name &#39;threadpool %03i&#39; % spawned</span><br><span class="line">    todo  &#x3D; @todo</span><br><span class="line">    block &#x3D; @block</span><br><span class="line"></span><br><span class="line">    while true</span><br><span class="line">      work &#x3D; nil</span><br><span class="line"></span><br><span class="line">      continue &#x3D; true</span><br><span class="line"></span><br><span class="line">      mutex.synchronize do</span><br><span class="line">        work &#x3D; todo.shift if continue</span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">      break unless continue</span><br><span class="line"></span><br><span class="line">      begin</span><br><span class="line">        block.call(work, *extra)</span><br><span class="line">      rescue Exception &#x3D;&gt; e</span><br><span class="line">        STDERR.puts &quot;Error reached top of thread-pool: #&#123;e.message&#125; (#&#123;e.class&#125;)&quot;</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  @workers &lt;&lt; th</span><br><span class="line"></span><br><span class="line">  th</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>线程在创建的时候是一个while true的循环。当创建以后就会不断的从todo里获取请求然后进行处理，而真正处理请求的是 block.call(work, *extra) 这个回调。<br>接着我们再来看看这个回调的代码。也就是在线程池初始化的时候传进来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@thread_pool &#x3D; ThreadPool.new(@min_threads,</span><br><span class="line">                              @max_threads,</span><br><span class="line">                              IOBuffer) do |client, buffer|</span><br><span class="line"></span><br><span class="line">  # Advertise this server into the thread</span><br><span class="line">  Thread.current[ThreadLocalKey] &#x3D; self</span><br><span class="line"></span><br><span class="line">  process_now &#x3D; false</span><br><span class="line"></span><br><span class="line">  begin</span><br><span class="line">    if queue_requests</span><br><span class="line">      process_now &#x3D; client.eagerly_finish</span><br><span class="line">    else</span><br><span class="line">      client.finish</span><br><span class="line">      process_now &#x3D; true</span><br><span class="line">    end</span><br><span class="line">  else</span><br><span class="line">    if process_now</span><br><span class="line">      process_client client, buffer</span><br><span class="line">    else</span><br><span class="line">      client.set_timeout @first_data_timeout</span><br><span class="line">      @reactor.add client</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这里会看请求队列里是否有请求，同时看请求是否准备好。如果准备好就立刻执行。** process_client client, buffer **</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def process_client(client, buffer)</span><br><span class="line">    handle_request(client, buffer)</span><br><span class="line">end</span><br><span class="line">def handle_request(req, lines)</span><br><span class="line">  env &#x3D; req.env</span><br><span class="line">  begin</span><br><span class="line">    begin</span><br><span class="line">      status, headers, res_body &#x3D; @app.call(env)</span><br><span class="line"></span><br><span class="line">      return :async if req.hijacked</span><br><span class="line"></span><br><span class="line">      status &#x3D; status.to_i</span><br><span class="line"></span><br><span class="line">      if status &#x3D;&#x3D; -1</span><br><span class="line">        unless headers.empty? and res_body &#x3D;&#x3D; []</span><br><span class="line">          raise &quot;async response must have empty headers and body&quot;</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        return :async</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>到这里就比较熟悉了，这个地方就会交给rails 等类似框架进行处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/12/puma%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" data-id="cka4t5bxs00014aon6cc40qlo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/puma-rails/" rel="tag">puma rails</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/05/12/rack%E7%9B%B8%E5%85%B3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">rack相关</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/puma-rails/" rel="tag">puma rails</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rack-rails/" rel="tag">rack rails</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/puma-rails/" style="font-size: 10px;">puma rails</a> <a href="/tags/rack-rails/" style="font-size: 10px;">rack rails</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/12/puma%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">puma原理解析</a>
          </li>
        
          <li>
            <a href="/2020/05/12/rack%E7%9B%B8%E5%85%B3/">rack相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>